#ifndef SALES_DATA_H
#define SALES_DATA_H

#include <iostream>

// Structs have all members public by default
// Classes have all members private by default
// You can use public and private as many times as you want
struct SalesData
{
    public:
    // Members of a class are declared inside the class
    // Member functions defined inside the class are implicitly inline

    // In this function we return a reference to a SalesData class
    // By derefencing special address 'this' we can get the current object
    SalesData & combine(const SalesData & rhs)
    {
        if (isbn() == rhs.isbn())
        {
            numSold += rhs.numSold;
            revenue += rhs.revenue;
        }
        return *this;
    }
    // const after parameter list denotes a const function that cannot modify
    // the object in any way
    // What's really happening is that the implicit this pointer is converted
    // into a low-level const pointer so the object it points to is a const
    // and thus cannot be modified
    // Const objects can ONLY call const member functions
    std::string isbn() const { return bookNo;}
    private:
    inline double avg_price() const
    {
        return numSold ? revenue / numSold : 0.0;
    }
    // Constructors are functions that run when the object is created
    // Constructors have no return type and they share the name with the object
    // Constructors can also be overloaded
    // A default constructor is generated by the compiler if one is not defined
    // The default constructor will simply initialize the members of an object
    // with the values provided or default-initialized if a value is not
    // provided (bookNo below is default-initialized)
    // numSold and revenue are initialized with the provided values

    // Since we are defining other constructors we can use this line to
    // generate a default constructor
    public:
    SalesData() = default;
    // This is equivalent to:
    // SalesData()
    // {
    //     bookNo = ""; // default-initialized strings are empty strings
    //     numSold = 0;
    //     revenue = 0.0;
    // }

    // Next constructor uses a constructor initializer list (after the colon)
    // This is the standard and preferred way of assigning to object members
    // because it initializes the member as that value
    // If we assigned values we would have issues with any const members
    // The empty function body comes afterwards and is left empty since
    // assignment to the members is done and no other work is needed
    SalesData(const std::string & s, unsigned num, double price):
        bookNo(s), numSold(num), revenue(price * num) {}

    // Next constructor only needs a string for the ISBN
    // Function body is still empty because the other values will still be
    // initialized with the values provided "in-class" below
    SalesData(const std::string & s): bookNo(s) {}

    // This constructor is only declared since it will actually do work
    // inside the function body
    SalesData(std::istream & is)
    {
        read(is, *this);
    }

    private:
    std::string bookNo;
    unsigned numSold = 0;
    double revenue = 0.0;

    // friend functions are allowed to access private members
    // friend declarations ARE NOT counted as normal declarations as well
    friend std::istream & read(std::istream &, SalesData &);
    friend std::ostream & print(std::ostream &, const SalesData &);
    friend SalesData add(const SalesData &, const SalesData &);
    
};

// We must ALSO declare the friend functions normally to allow users access
// Note that this rule is left up to the compiler
// so in some cases we can still use them with only the friend declarations
std::istream & read(std::istream &, SalesData &);
std::ostream & print(std::ostream &, const SalesData &);
SalesData add(const SalesData &, const SalesData &);

#endif